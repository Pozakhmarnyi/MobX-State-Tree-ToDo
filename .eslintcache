[{"C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\index.js":"1","C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\App.js":"2","C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\store\\utils.js":"3","C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\store\\TodoStore.js":"4","C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\store\\RootStore.js":"5","C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\store\\GroupStore.js":"6","C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\components\\Add_Item.js":"7"},{"size":214,"mtime":1606851844728,"results":"8","hashOfConfig":"9"},{"size":3004,"mtime":1608658286324,"results":"10","hashOfConfig":"9"},{"size":81,"mtime":1606142873484,"results":"11","hashOfConfig":"9"},{"size":4006,"mtime":1607860255879,"results":"12","hashOfConfig":"9"},{"size":1645,"mtime":1608413233082,"results":"13","hashOfConfig":"9"},{"size":2438,"mtime":1608649444313,"results":"14","hashOfConfig":"9"},{"size":104,"mtime":1607353865751,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"cpnq65",{"filePath":"19","messages":"20","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"23"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26","usedDeprecatedRules":"27"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"23"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32","usedDeprecatedRules":"23"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},"C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\index.js",[],["36","37"],"C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\App.js",["38"],"C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\store\\utils.js",[],["39","40"],"C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\store\\TodoStore.js",["41"],"import { types as t } from 'mobx-state-tree';\r\nimport { v4 as uID } from 'uuid';\r\n\r\nconst state = {\r\n\tlist: [\r\n\t\t{\r\n\t\t\tid: uID(),\r\n\t\t\ttitle: 'popato'\r\n\t\t}\r\n\t]\r\n}\r\n\r\n// class TodoModel {      // модель - (хоч говори форма) якою будемо наділяти наші нові об\"єкти\r\n// \tconstructor(id, title) {\r\n// \t\tthis.id = id;\r\n// \t\tthis.title = title;\r\n// \t}\r\n// }\r\n// const todo = new TodoModel(uID, \"Oil\")  --- І наш новий о\"єкт з заданою формою\r\n\r\n// Нижче те саме, але на 'mobx-state-tree'\r\n\r\nexport const TodoModel = t\r\n\t.model('TodoModel', {\t\t\t\t// надаю форму моделі\r\n\t\tid: t.identifier, // - індифікатор для наших посилань -> референсів\r\n\t\ttitle: t.string,\r\n\t\tisCompleted: t.optional(t.boolean, false),\t\t\t// опціонально, з дефолтним фолс\r\n\t\tisFavorite: t.optional(t.boolean, false),\r\n\t})\r\n\t.actions((self) => ({\r\n\t\ttoggleCompleted() {\r\n\t\t\tself.isCompleted = !self.isCompleted\r\n\t\t},\r\n\t\ttoggleFavorite() {\r\n\t\t\tself.isFavorite = !self.isFavorite\r\n\t\t}\r\n\r\n\t}));\r\n\r\n// const newTodo = TodoModel.create({ id: uID(), title: 'Fas' })\r\n\r\n// newTodo.isCompleted = true;      ТАК Є ПОМИЛКА, оскільки для внутрішньої зміни елементів у MST - треба робити через .actions і там створити якийсь метод - у нашому випадко toggleCompleted() {self.isCompleted = !self.isCompleted}\r\n// prettyPrint(newTodo);\r\n\r\n// newTodo.toggleCompleted()       // Ось так - Абсолютно законно ! %) \r\n// prettyPrint(newTodo);\r\n\r\n\r\nexport const TodoListModel = t\r\n\t.model('TodoListModel', { // наш MST - буде знати автоматично, що вміст нашого масиву матиме тип TodoModel ТАк -> list: t.array(TodoModel)\r\n\t\tid: uID(),\r\n\t\ttitle: t.optional(t.string, 'TodoList'),\r\n\t\tlist: t.array(TodoModel), \t\t\t\t\t\t\t//якщо t.optional (\"першим аргументом - те,що повинно бути!\" , а другим це по дефолту, якщо нема першого)\r\n\t})\r\n\t.views((self) => ({\r\n\t\tget favoriteList() {\r\n\t\t\treturn self.list.filter(item => item.isFavorite)   // окремо відфільткував з усього і викликав як об\"єкт - так робити, як з олюбненим товаром, так і дaні юзерів\r\n\t\t},\r\n\t\tget ifComplete() {\r\n\t\t\tlet count = 0\r\n\t\t\tfor (let i = 0; i < self.list.length; i++) {\r\n\t\t\t\tif (self.list[i].isCompleted === true) { count++ }\r\n\t\t\t}\r\n\t\t\treturn count\r\n\t\t}\r\n\r\n\t}))\r\n\t.actions((self) => ({  \t\t   \t// оскільки це MST - тут не можна вручну добивити, ще щось. І методи .push() і їм подібні, не поможуть, треба робити .action ІЗ своїми методами\r\n\t\tadd(title) {\t// get писати перед методом, коли нема потреби в пропсах - зараз у пропсі (title)\r\n\t\t\tconst todo = {\t\t    //const todo = TodoModel.create({...}) так не обо\"язково вказувати, оскільки MST знає, яку можедель ми використовуємо\r\n\t\t\t\tid: uID(),\r\n\t\t\t\ttitle,\r\n\t\t\t}\r\n\r\n\t\t\tself.list.unshift(todo)\r\n\t\t},\r\n\r\n\t\t// У .views перед методами варто ставити get - якщо їм не треба пропсів. get - кешується, і не буде щоразу запускатись, якщо наш стейт\\self не мінявся  \r\n\t}))\r\n\r\n// const todo = TodoModel.create({ \t\t\t\t\t\t// створення об\"яку\r\n// \tid: uID(),\r\n// \ttitle: 'egg',\r\n// })\r\n\r\n\r\n// const todoList = TodoListModel.create(state)\r\n\r\n// todoList.add('chocolate')\r\n// todoList.add('oil')\r\n\r\n// todoList.list[1].toggleCompleted();\r\n// todoList.list[0].toggleFavorite();\r\n\r\n\r\n\r\n// prettyPrint(todoList.favoriteList);\r\n\r\n\r\n// prettyPrint(todoList);\r\n",["42","43"],"C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\store\\RootStore.js",[],"C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\store\\GroupStore.js",["44"],"import { types as t } from 'mobx-state-tree';\r\nimport { v4 as uID } from 'uuid';\r\nimport rootStore from './RootStore';\r\nimport { TodoModel } from './TodoStore';\r\n\r\n\r\nconst GroupModel = t\r\n\t.model('GroupModel', {\t\t\t\t\t// надаю форму моделі\r\n\t\tid: t.string,\r\n\t\ttitle: t.string,\r\n\t\t// todos: t.array(t.reference(TodoModel)),\r\n\t\ttodos: t.array(TodoModel),\r\n\t})\r\n\t.views((self) => ({\r\n\t\t// get favoriteList() {\r\n\t\t// \treturn self.list.filter(item => item.isFavorite)   // окремо відфільткував з усього і викликав як об\"єкт - так робити, як з олюбненим товаром, так і дaні юзерів\r\n\t\t// },\r\n\t\tget ifComplete() {\r\n\t\t\tlet count = 0\r\n\t\t\tfor (let i = 0; i < self.todos.length; i++) {\r\n\t\t\t\tif (self.todos[i].isCompleted === true) { count++ }\r\n\t\t\t}\r\n\t\t\treturn count\r\n\t\t}\r\n\r\n\t}))\r\n\r\n\t.actions((self) => ({\r\n\t\taddTodo(title) {\r\n\t\t\tconst todo = {\r\n\t\t\t\tid: uID(),\r\n\t\t\t\ttitle,\r\n\t\t\t}\r\n\t\t\tself.todos.unshift(todo)\r\n\t\t},\r\n\t\ttoggleCompleted() {\r\n\t\t\tself.isCompleted = !self.isCompleted\r\n\t\t},\r\n\t\ttoggleFavorite() {\r\n\t\t\tself.isFavorite = !self.isFavorite\r\n\t\t}\r\n\r\n\t}));\r\n\r\n\r\n\r\nexport const GroupListModel = t\r\n\t.model('GroupListModel', {\r\n\t\tid: uID(),\r\n\t\ttitle: t.optional(t.string, 'GroupList'),\r\n\t\tlist: t.array(GroupModel), \t\t\t\t\t\t\t// олюблена моя частина - Вкладеність \r\n\t})\r\n\t.views((self) => ({\r\n\t\tget favoriteList() {\r\n\t\t\treturn self.list.filter(item => item.isFavorite)   // окремо відфільткував з усього і викликав як об\"єкт - так робити, як з олюбненим товаром, так і дaні юзерів\r\n\t\t},\r\n\t\tget ifComplete() {\r\n\t\t\tlet count = 0\r\n\t\t\tfor (let i = 0; i < self.list.length; i++) {\r\n\t\t\t\tif (self.list[i].isCompleted === true) { count++ }\r\n\t\t\t}\r\n\t\t\treturn count\r\n\t\t}\r\n\r\n\t}))\r\n\t.actions((self) => ({\r\n\t\tadd(title) {\r\n\t\t\tconst group = {\r\n\t\t\t\tid: uID(),\r\n\t\t\t\ttitle,\r\n\t\t\t}\r\n\t\t\tself.list.unshift(group)\r\n\t\t},\r\n\t}))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// const group = GroupModel.create({\r\n// \tid: uID(),\r\n// \ttitle: 'My new list',\r\n// })\r\n\r\n// const groupList = GroupListModel.create({\r\n// \tlist: [group]\r\n// })\r\n\r\n// const todoList = TodoListModel.create(state)\r\n\r\n// todoList.add('chocolate')\r\n// todoList.add('oil')\r\n\r\n// todoList.list[1].toggleCompleted();\r\n// todoList.list[0].toggleFavorite();\r\n\r\n\r\n\r\n// prettyPrint(todoList.favoriteList);\r\n\r\n// prettyPrint(todoList);\r\n\r\n","C:\\Users\\Pinav\\Desktop\\Stady\\MobX\\mst-todo\\src\\components\\Add_Item.js",[],["45","46"],{"ruleId":"47","replacedBy":"48"},{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","severity":1,"message":"52","line":7,"column":10,"nodeType":"53","messageId":"54","endLine":7,"endColumn":21},{"ruleId":"47","replacedBy":"55"},{"ruleId":"49","replacedBy":"56"},{"ruleId":"51","severity":1,"message":"57","line":4,"column":7,"nodeType":"53","messageId":"54","endLine":4,"endColumn":12},{"ruleId":"47","replacedBy":"58"},{"ruleId":"49","replacedBy":"59"},{"ruleId":"51","severity":1,"message":"60","line":3,"column":8,"nodeType":"53","messageId":"54","endLine":3,"endColumn":17},{"ruleId":"47","replacedBy":"61"},{"ruleId":"49","replacedBy":"62"},"no-native-reassign",["63"],"no-negated-in-lhs",["64"],"no-unused-vars","'prettyPrint' is defined but never used.","Identifier","unusedVar",["63"],["64"],"'state' is assigned a value but never used.",["63"],["64"],"'rootStore' is defined but never used.",["63"],["64"],"no-global-assign","no-unsafe-negation"]